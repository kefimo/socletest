import { __awaiter, __decorate, __metadata } from 'tslib';
import { defineInjectable, Injectable, EventEmitter, Output, Input, Directive, ElementRef, Renderer2, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { startWith, map } from 'rxjs/operators';

/**
 * Global Options
 */
class UploadxOptions {
}

function resolveUrl(url, baseURI) {
    if (url.indexOf('//') * url.indexOf('https://') * url.indexOf('http://') === 0) {
        return url;
    }
    try {
        const res = new URL(url, baseURI).href;
        return res;
    }
    catch (_a) {
        if (url.indexOf('/') === 0) {
            const matches = baseURI.match(/^(?:https?:)?(?:\/\/)?([^\/\?]+)/g);
            const origin = matches && matches[0];
            return origin + url;
        }
        else {
            const matches = baseURI.match(/^(?:https?:)?(?:\/\/)?([^\/\?]+)?(.*\/)/g);
            const path = matches && matches[0];
            return path + url;
        }
    }
}

/**
 *  Exponential Backoff Retries
 */
class BackoffRetry {
    /**
     * @param min  Initial retry delay
     * @param max  Max retry delay
     * @param k    Increase factor
     */
    constructor(min = 200, max = min * 300, k = 2) {
        this.min = min;
        this.max = max;
        this.k = k;
        this.code = -1;
        this.retryAttempts = 1;
        this.delay = this.min;
    }
    /**
     * Delay Retry
     * @param code
     * @returns retryAttempts
     */
    wait(code) {
        return new Promise(resolve => {
            if (code === this.code) {
                this.retryAttempts++;
                this.delay = Math.min(this.delay * this.k, this.max);
            }
            else {
                this.delay = this.min;
                this.retryAttempts = 1;
            }
            this.code = code;
            setTimeout(() => resolve(this.retryAttempts), this.delay + Math.floor(Math.random() * this.min));
        });
    }
    /**
     * Reset Retry
     */
    reset() {
        this.delay = this.min;
        this.retryAttempts = 1;
        this.code = -1;
    }
}

/**
 * Implements XHR/CORS Resumable Upload
 * @see
 * https://developers.google.com/drive/v3/web/resumable-upload
 */
const noop = () => { };
class Uploader {
    /**
     * Creates an instance of Uploader.
     */
    constructor(file, options) {
        this.file = file;
        this.options = options;
        this.retry = new BackoffRetry();
        this.chunkSize = 1048576;
        this.maxRetryAttempts = 3;
        this.uploadId = Math.random()
            .toString(36)
            .substring(2, 15);
        this.name = file.name;
        this.size = file.size;
        this.mimeType = file.type || 'application/octet-stream';
        this.stateChange = options.stateChange || noop;
        this.configure(options);
    }
    set status(s) {
        // Return if State is cancelled or complete (but allow cancel of an complete upload to remove from list and from server)
        if (this._status === 'cancelled' || (this._status === 'complete' && s !== 'cancelled')) {
            return;
        }
        if (s !== this._status) {
            if (this._xhr_ && (s === 'cancelled' || s === 'paused')) {
                this._xhr_.abort();
            }
            if (s === 'cancelled' && this.URI) {
                this.request('delete');
            }
            this._status = s;
            this.notifyState();
        }
    }
    get status() {
        return this._status;
    }
    /**
     * configure or reconfigure uploader
     */
    configure(item = {}) {
        const { metadata, headers, token, endpoint } = item;
        this.metadata = Object.assign({ name: this.name, mimeType: this.mimeType, size: this.file.size, lastModified: this.file.lastModified }, unfunc(metadata || this.metadata, this.file));
        this.endpoint = endpoint || this.options.endpoint;
        this.chunkSize = this.options.chunkSize || this.chunkSize;
        this.maxRetryAttempts = this.options.maxRetryAttempts || this.maxRetryAttempts;
        this.refreshToken(token);
        this.headers = Object.assign({}, this.headers, unfunc(headers, this.file));
    }
    /**
     * Emit current state
     */
    notifyState() {
        const state = {
            file: this.file,
            name: this.name,
            progress: this.progress,
            percentage: this.progress,
            remaining: this.remaining,
            response: this.response,
            responseStatus: this.responseStatus,
            size: this.size,
            speed: this.speed,
            status: this._status,
            uploadId: this.uploadId,
            URI: this.URI
        };
        this.stateChange(state);
    }
    processResponse(xhr) {
        this.responseStatus = xhr.status;
        this.response = parseJson(xhr);
        this.statusType = xhr.status - (xhr.status % 100);
    }
    refreshToken(token) {
        this.token = token || this.token;
        this._token = unfunc(this.token);
    }
    maxAttemptsReached() {
        if (this.retry.retryAttempts === this.maxRetryAttempts && this.statusType === 400) {
            this.retry.reset();
            console.error(`Error: Maximum number of retry attempts reached:
          file: ${this.name},
          statusCode: ${this.responseStatus}`);
            return true;
        }
    }
    create() {
        return new Promise((resolve, reject) => {
            if (!this.URI || this.responseStatus === 404) {
                // get file URI
                const xhr = new XMLHttpRequest();
                xhr.open(this.options.method.toUpperCase(), this.endpoint, true);
                this.setupXHR(xhr);
                xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
                xhr.setRequestHeader('X-Upload-Content-Length', this.size.toString());
                xhr.setRequestHeader('X-Upload-Content-Type', this.mimeType);
                xhr.onload = () => {
                    this.processResponse(xhr);
                    const location = this.statusType === 200 && getKeyFromResponse(xhr, 'location');
                    if (!location) {
                        // limit attempts
                        this.statusType = 400;
                        reject();
                    }
                    else {
                        this.URI = resolveUrl(location, this.endpoint);
                        this.retry.reset();
                        resolve();
                    }
                };
                xhr.onerror = () => reject();
                xhr.send(JSON.stringify(this.metadata));
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Initiate upload
     */
    upload(item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (item)
                this.configure(item);
            if (this._status === 'cancelled' || this._status === 'complete' || this._status === 'paused') {
                return;
            }
            this.status = 'uploading';
            this.refreshToken();
            try {
                yield this.create();
                this.startTime = new Date().getTime();
                this.sendChunk(this.progress ? undefined : 0);
            }
            catch (e) {
                if (this.maxAttemptsReached()) {
                    this.status = 'error';
                }
                else {
                    this.status = 'retry';
                    yield this.retry.wait(this.responseStatus);
                    this.status = 'queue';
                }
            }
        });
    }
    /**
     * Chunk upload +/ get offset
     */
    sendChunk(offset) {
        if (this.status === 'uploading') {
            let body = null;
            const xhr = new XMLHttpRequest();
            xhr.open('PUT', this.URI, true);
            this.setupXHR(xhr);
            this.setupEvents(xhr);
            if (offset >= 0 && offset < this.size) {
                const end = this.chunkSize ? Math.min(offset + this.chunkSize, this.size) : this.size;
                body = this.file.slice(offset, end);
                xhr.upload.onprogress = this.setupProgressEvent(offset, end);
                xhr.setRequestHeader('Content-Range', `bytes ${offset}-${end - 1}/${this.size}`);
                xhr.setRequestHeader('Content-Type', 'application/octet-stream');
            }
            else {
                xhr.setRequestHeader('Content-Range', `bytes */${this.size}`);
            }
            xhr.send(body);
        }
    }
    setupEvents(xhr) {
        const onError = () => __awaiter(this, void 0, void 0, function* () {
            if (this.maxAttemptsReached()) {
                this.status = 'error';
                return;
            }
            this.status = 'retry';
            yield this.retry.wait(xhr.status);
            if (xhr.status === 404) {
                this.status = 'queue';
                return;
            }
            if (xhr.status === 413) {
                this.chunkSize /= 2;
            }
            this.refreshToken();
            this.status = 'uploading';
            // request offset
            this.sendChunk();
        });
        const onSuccess = () => {
            this.processResponse(xhr);
            const offset = this.statusType === 300 && this.getNextChunkOffset(xhr);
            if (typeof offset === 'number') {
                //  next chunk
                this.retry.reset();
                this.sendChunk(offset);
            }
            else if (this.statusType === 200) {
                this.progress = 100;
                this.status = 'complete';
            }
            else {
                onError();
            }
        };
        xhr.onerror = onError;
        xhr.onload = onSuccess;
    }
    setupProgressEvent(offset, end) {
        return (pEvent) => {
            const uploaded = pEvent.lengthComputable
                ? offset + (end - offset) * (pEvent.loaded / pEvent.total)
                : offset;
            this.progress = +((uploaded / this.size) * 100).toFixed(2);
            const now = new Date().getTime();
            this.speed = Math.round((uploaded / (now - this.startTime)) * 1000);
            this.remaining = Math.ceil((this.size - uploaded) / this.speed);
            this.notifyState();
        };
    }
    getNextChunkOffset(xhr) {
        const str = getKeyFromResponse(xhr, 'Range');
        const [match] = str && str.match(/(-1|\d+)$/g);
        return match && +match + 1;
    }
    setupXHR(xhr) {
        //reset response
        this.responseStatus = null;
        this.response = null;
        this.statusType = null;
        this._xhr_ = xhr;
        xhr.responseType = 'json';
        xhr.withCredentials = this.options.withCredentials;
        Object.keys(this.headers).forEach(key => xhr.setRequestHeader(key, this.headers[key]));
        // tslint:disable-next-line: no-unused-expression
        this._token && xhr.setRequestHeader('Authorization', `Bearer ${this._token}`);
    }
    request(method, payload = null) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open(method.toUpperCase(), this.URI, true);
            this.setupXHR(xhr);
            xhr.onload = () => {
                this.processResponse(xhr);
                resolve();
            };
            xhr.onerror = () => reject();
            const body = payload ? JSON.stringify(payload) : null;
            xhr.send(body);
        });
    }
}
function getKeyFromResponse(xhr, key) {
    const fromHeader = xhr.getResponseHeader(key);
    if (fromHeader) {
        return fromHeader;
    }
    const response = parseJson(xhr) || {};
    const resKey = Object.keys(response).find(k => k.toLowerCase() === key.toLowerCase());
    return response[resKey];
}
function parseJson(xhr) {
    return typeof xhr.response === 'object' ? xhr.response : JSON.parse(xhr.responseText || null);
}
function unfunc(value, file) {
    return value instanceof Function ? value(file) : value;
}

let UploadxService = class UploadxService {
    constructor() {
        this.eventsStream = new Subject();
        this.queue = [];
        this.concurrency = 2;
        this.autoUpload = true;
        this.stateChange = (evt) => {
            setTimeout(() => {
                this.eventsStream.next(evt);
            });
        };
        this.events.subscribe((evt) => {
            if (evt.status !== 'uploading' && evt.status !== 'added') {
                this.processQueue();
            }
        });
    }
    get events() {
        return this.eventsStream.asObservable();
    }
    get uploaderOptions() {
        return {
            method: this.options.method || 'POST',
            // tslint:disable-next-line: deprecation
            endpoint: this.options.endpoint || this.options.url || '/upload',
            headers: this.options.headers,
            metadata: this.options.metadata,
            token: this.options.token,
            chunkSize: this.options.chunkSize,
            withCredentials: this.options.withCredentials,
            maxRetryAttempts: this.options.maxRetryAttempts,
            stateChange: this.stateChange
        };
    }
    /**
     * Initializes service
     * @param options global options
     * @returns Observable that emits a new value on progress or status changes
     */
    init(options) {
        this.options = options;
        this.concurrency = options.concurrency || this.concurrency;
        this.autoUpload = !(options.autoUpload === false);
        return this.events;
    }
    /**
     * Initializes service
     * @param options global options
     * @returns Observable that emits the current queue
     */
    connect(options) {
        return this.init(options || this.options).pipe(startWith(0), map(() => this.queue));
    }
    /**
     * Terminate all uploads and clears the queue
     */
    disconnect() {
        this.queue.forEach(f => (f.status = 'paused'));
        this.queue = [];
    }
    /**
     * Create Uploader and add to the queue
     */
    handleFileList(fileList) {
        for (let i = 0; i < fileList.length; i++) {
            const uploader = new Uploader(fileList.item(i), this.uploaderOptions);
            this.queue.push(uploader);
            uploader.status = 'added';
        }
        this.autoUploadFiles();
    }
    /**
     * Create Uploader for the file and add to the queue
     */
    handleFile(file) {
        const uploader = new Uploader(file, this.uploaderOptions);
        this.queue.push(uploader);
        uploader.status = 'added';
        this.autoUploadFiles();
    }
    /**
     * Auto upload the files if the flag is true
     * @internal
     */
    autoUploadFiles() {
        if (this.autoUpload) {
            this.queue.filter(f => f.status === 'added').forEach(f => (f.status = 'queue'));
        }
    }
    /**
     * Control uploads status
     * @example
     * this.uploadService.control({ action: 'pauseAll' });
     *
     */
    control(event) {
        switch (event.action) {
            case 'cancelAll':
                this.queue.forEach(f => (f.status = 'cancelled'));
                break;
            case 'pauseAll':
                this.queue.forEach(f => (f.status = 'paused'));
                break;
            case 'refreshToken':
                this.queue.forEach(f => f.refreshToken(event.token));
                break;
            case 'uploadAll':
                this.queue.filter(f => f.status !== 'uploading').forEach(f => (f.status = 'queue'));
                break;
            case 'upload':
                const uploadId = event.uploadId || event.itemOptions.uploadId;
                const upload = this.queue.find(f => f.uploadId === uploadId);
                upload.configure(event.itemOptions);
                upload.status = 'queue';
                break;
            case 'cancel':
                this.queue.find(f => f.uploadId === event.uploadId).status = 'cancelled';
                break;
            case 'pause':
                this.queue.find(f => f.uploadId === event.uploadId).status = 'paused';
                break;
            default:
                break;
        }
    }
    /**
     * Queue management
     * @internal
     */
    processQueue() {
        // Remove Cancelled Items from local queue
        this.queue = this.queue.filter(f => f.status !== 'cancelled');
        const running = this.runningProcess();
        this.queue
            .filter((uploader) => uploader.status === 'queue')
            .slice(0, Math.max(this.concurrency - running, 0))
            .forEach((uploader) => {
            uploader.upload();
        });
    }
    /**
     * @returns  number of active uploads
     */
    runningProcess() {
        return this.queue.filter((uploader) => uploader.status === 'uploading' || uploader.status === 'retry').length;
    }
};
UploadxService.ngInjectableDef = defineInjectable({ factory: function UploadxService_Factory() { return new UploadxService(); }, token: UploadxService, providedIn: "root" });
UploadxService = __decorate([
    Injectable({ providedIn: 'root' }),
    __metadata("design:paramtypes", [])
], UploadxService);

let UploadxDirective = class UploadxDirective {
    constructor(elementRef, renderer, uploadService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.uploadService = uploadService;
        this.uploadxState = new EventEmitter();
        this.fileListener = () => {
            if (this.elementRef.nativeElement.files) {
                this.uploadService.handleFileList(this.elementRef.nativeElement.files);
            }
        };
    }
    set uploadxAction(ctrlEvent) {
        if (ctrlEvent && this.uploadService) {
            this.uploadService.control(ctrlEvent);
        }
    }
    ngOnInit() {
        if (this.uploadx) {
            if (this.uploadx.allowedTypes) {
                this.renderer.setAttribute(this.elementRef.nativeElement, 'accept', this.uploadx.allowedTypes);
            }
            this.uploadService.init(this.uploadx);
        }
        this.uploadxState.emit(this.uploadService.events);
        this.listenerFn = this.renderer.listen(this.elementRef.nativeElement, 'change', this.fileListener);
    }
    ngOnDestroy() {
        if (this.listenerFn) {
            this.listenerFn();
        }
    }
};
__decorate([
    Output(),
    __metadata("design:type", Object)
], UploadxDirective.prototype, "uploadxState", void 0);
__decorate([
    Input(),
    __metadata("design:type", UploadxOptions)
], UploadxDirective.prototype, "uploadx", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], UploadxDirective.prototype, "uploadxAction", null);
UploadxDirective = __decorate([
    Directive({
        selector: '[uploadx]'
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        UploadxService])
], UploadxDirective);

let UploadxModule = class UploadxModule {
};
UploadxModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [UploadxDirective],
        exports: [UploadxDirective]
    })
], UploadxModule);

/**
 * Generated bundle index. Do not edit.
 */

export { Uploader, UploadxModule, UploadxOptions, UploadxService, UploadxDirective as ɵa };
//# sourceMappingURL=ngx-uploadx.js.map

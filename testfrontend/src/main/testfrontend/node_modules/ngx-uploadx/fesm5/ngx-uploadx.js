import { __assign, __awaiter, __generator, __read, __decorate, __metadata } from 'tslib';
import { defineInjectable, Injectable, Output, Input, Directive, ElementRef, Renderer2, EventEmitter, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { startWith, map } from 'rxjs/operators';

/**
 * Global Options
 */
var UploadxOptions = /** @class */ (function () {
    function UploadxOptions() {
    }
    return UploadxOptions;
}());

function resolveUrl(url, baseURI) {
    if (url.indexOf('//') * url.indexOf('https://') * url.indexOf('http://') === 0) {
        return url;
    }
    try {
        var res = new URL(url, baseURI).href;
        return res;
    }
    catch (_a) {
        if (url.indexOf('/') === 0) {
            var matches = baseURI.match(/^(?:https?:)?(?:\/\/)?([^\/\?]+)/g);
            var origin_1 = matches && matches[0];
            return origin_1 + url;
        }
        else {
            var matches = baseURI.match(/^(?:https?:)?(?:\/\/)?([^\/\?]+)?(.*\/)/g);
            var path = matches && matches[0];
            return path + url;
        }
    }
}

/**
 *  Exponential Backoff Retries
 */
var BackoffRetry = /** @class */ (function () {
    /**
     * @param min  Initial retry delay
     * @param max  Max retry delay
     * @param k    Increase factor
     */
    function BackoffRetry(min, max, k) {
        if (min === void 0) { min = 200; }
        if (max === void 0) { max = min * 300; }
        if (k === void 0) { k = 2; }
        this.min = min;
        this.max = max;
        this.k = k;
        this.code = -1;
        this.retryAttempts = 1;
        this.delay = this.min;
    }
    /**
     * Delay Retry
     * @param code
     * @returns retryAttempts
     */
    BackoffRetry.prototype.wait = function (code) {
        var _this = this;
        return new Promise(function (resolve) {
            if (code === _this.code) {
                _this.retryAttempts++;
                _this.delay = Math.min(_this.delay * _this.k, _this.max);
            }
            else {
                _this.delay = _this.min;
                _this.retryAttempts = 1;
            }
            _this.code = code;
            setTimeout(function () { return resolve(_this.retryAttempts); }, _this.delay + Math.floor(Math.random() * _this.min));
        });
    };
    /**
     * Reset Retry
     */
    BackoffRetry.prototype.reset = function () {
        this.delay = this.min;
        this.retryAttempts = 1;
        this.code = -1;
    };
    return BackoffRetry;
}());

/**
 * Implements XHR/CORS Resumable Upload
 * @see
 * https://developers.google.com/drive/v3/web/resumable-upload
 */
var noop = function () { };
var Uploader = /** @class */ (function () {
    /**
     * Creates an instance of Uploader.
     */
    function Uploader(file, options) {
        this.file = file;
        this.options = options;
        this.retry = new BackoffRetry();
        this.chunkSize = 1048576;
        this.maxRetryAttempts = 3;
        this.uploadId = Math.random()
            .toString(36)
            .substring(2, 15);
        this.name = file.name;
        this.size = file.size;
        this.mimeType = file.type || 'application/octet-stream';
        this.stateChange = options.stateChange || noop;
        this.configure(options);
    }
    Object.defineProperty(Uploader.prototype, "status", {
        get: function () {
            return this._status;
        },
        set: function (s) {
            // Return if State is cancelled or complete (but allow cancel of an complete upload to remove from list and from server)
            if (this._status === 'cancelled' || (this._status === 'complete' && s !== 'cancelled')) {
                return;
            }
            if (s !== this._status) {
                if (this._xhr_ && (s === 'cancelled' || s === 'paused')) {
                    this._xhr_.abort();
                }
                if (s === 'cancelled' && this.URI) {
                    this.request('delete');
                }
                this._status = s;
                this.notifyState();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * configure or reconfigure uploader
     */
    Uploader.prototype.configure = function (item) {
        if (item === void 0) { item = {}; }
        var metadata = item.metadata, headers = item.headers, token = item.token, endpoint = item.endpoint;
        this.metadata = __assign({ name: this.name, mimeType: this.mimeType, size: this.file.size, lastModified: this.file.lastModified }, unfunc(metadata || this.metadata, this.file));
        this.endpoint = endpoint || this.options.endpoint;
        this.chunkSize = this.options.chunkSize || this.chunkSize;
        this.maxRetryAttempts = this.options.maxRetryAttempts || this.maxRetryAttempts;
        this.refreshToken(token);
        this.headers = __assign({}, this.headers, unfunc(headers, this.file));
    };
    /**
     * Emit current state
     */
    Uploader.prototype.notifyState = function () {
        var state = {
            file: this.file,
            name: this.name,
            progress: this.progress,
            percentage: this.progress,
            remaining: this.remaining,
            response: this.response,
            responseStatus: this.responseStatus,
            size: this.size,
            speed: this.speed,
            status: this._status,
            uploadId: this.uploadId,
            URI: this.URI
        };
        this.stateChange(state);
    };
    Uploader.prototype.processResponse = function (xhr) {
        this.responseStatus = xhr.status;
        this.response = parseJson(xhr);
        this.statusType = xhr.status - (xhr.status % 100);
    };
    Uploader.prototype.refreshToken = function (token) {
        this.token = token || this.token;
        this._token = unfunc(this.token);
    };
    Uploader.prototype.maxAttemptsReached = function () {
        if (this.retry.retryAttempts === this.maxRetryAttempts && this.statusType === 400) {
            this.retry.reset();
            console.error("Error: Maximum number of retry attempts reached:\n          file: " + this.name + ",\n          statusCode: " + this.responseStatus);
            return true;
        }
    };
    Uploader.prototype.create = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this.URI || _this.responseStatus === 404) {
                // get file URI
                var xhr_1 = new XMLHttpRequest();
                xhr_1.open(_this.options.method.toUpperCase(), _this.endpoint, true);
                _this.setupXHR(xhr_1);
                xhr_1.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
                xhr_1.setRequestHeader('X-Upload-Content-Length', _this.size.toString());
                xhr_1.setRequestHeader('X-Upload-Content-Type', _this.mimeType);
                xhr_1.onload = function () {
                    _this.processResponse(xhr_1);
                    var location = _this.statusType === 200 && getKeyFromResponse(xhr_1, 'location');
                    if (!location) {
                        // limit attempts
                        _this.statusType = 400;
                        reject();
                    }
                    else {
                        _this.URI = resolveUrl(location, _this.endpoint);
                        _this.retry.reset();
                        resolve();
                    }
                };
                xhr_1.onerror = function () { return reject(); };
                xhr_1.send(JSON.stringify(_this.metadata));
            }
            else {
                resolve();
            }
        });
    };
    /**
     * Initiate upload
     */
    Uploader.prototype.upload = function (item) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (item)
                            this.configure(item);
                        if (this._status === 'cancelled' || this._status === 'complete' || this._status === 'paused') {
                            return [2 /*return*/];
                        }
                        this.status = 'uploading';
                        this.refreshToken();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 7]);
                        return [4 /*yield*/, this.create()];
                    case 2:
                        _a.sent();
                        this.startTime = new Date().getTime();
                        this.sendChunk(this.progress ? undefined : 0);
                        return [3 /*break*/, 7];
                    case 3:
                        e_1 = _a.sent();
                        if (!this.maxAttemptsReached()) return [3 /*break*/, 4];
                        this.status = 'error';
                        return [3 /*break*/, 6];
                    case 4:
                        this.status = 'retry';
                        return [4 /*yield*/, this.retry.wait(this.responseStatus)];
                    case 5:
                        _a.sent();
                        this.status = 'queue';
                        _a.label = 6;
                    case 6: return [3 /*break*/, 7];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Chunk upload +/ get offset
     */
    Uploader.prototype.sendChunk = function (offset) {
        if (this.status === 'uploading') {
            var body = null;
            var xhr = new XMLHttpRequest();
            xhr.open('PUT', this.URI, true);
            this.setupXHR(xhr);
            this.setupEvents(xhr);
            if (offset >= 0 && offset < this.size) {
                var end = this.chunkSize ? Math.min(offset + this.chunkSize, this.size) : this.size;
                body = this.file.slice(offset, end);
                xhr.upload.onprogress = this.setupProgressEvent(offset, end);
                xhr.setRequestHeader('Content-Range', "bytes " + offset + "-" + (end - 1) + "/" + this.size);
                xhr.setRequestHeader('Content-Type', 'application/octet-stream');
            }
            else {
                xhr.setRequestHeader('Content-Range', "bytes */" + this.size);
            }
            xhr.send(body);
        }
    };
    Uploader.prototype.setupEvents = function (xhr) {
        var _this = this;
        var onError = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.maxAttemptsReached()) {
                            this.status = 'error';
                            return [2 /*return*/];
                        }
                        this.status = 'retry';
                        return [4 /*yield*/, this.retry.wait(xhr.status)];
                    case 1:
                        _a.sent();
                        if (xhr.status === 404) {
                            this.status = 'queue';
                            return [2 /*return*/];
                        }
                        if (xhr.status === 413) {
                            this.chunkSize /= 2;
                        }
                        this.refreshToken();
                        this.status = 'uploading';
                        // request offset
                        this.sendChunk();
                        return [2 /*return*/];
                }
            });
        }); };
        var onSuccess = function () {
            _this.processResponse(xhr);
            var offset = _this.statusType === 300 && _this.getNextChunkOffset(xhr);
            if (typeof offset === 'number') {
                //  next chunk
                _this.retry.reset();
                _this.sendChunk(offset);
            }
            else if (_this.statusType === 200) {
                _this.progress = 100;
                _this.status = 'complete';
            }
            else {
                onError();
            }
        };
        xhr.onerror = onError;
        xhr.onload = onSuccess;
    };
    Uploader.prototype.setupProgressEvent = function (offset, end) {
        var _this = this;
        return function (pEvent) {
            var uploaded = pEvent.lengthComputable
                ? offset + (end - offset) * (pEvent.loaded / pEvent.total)
                : offset;
            _this.progress = +((uploaded / _this.size) * 100).toFixed(2);
            var now = new Date().getTime();
            _this.speed = Math.round((uploaded / (now - _this.startTime)) * 1000);
            _this.remaining = Math.ceil((_this.size - uploaded) / _this.speed);
            _this.notifyState();
        };
    };
    Uploader.prototype.getNextChunkOffset = function (xhr) {
        var str = getKeyFromResponse(xhr, 'Range');
        var _a = __read(str && str.match(/(-1|\d+)$/g), 1), match = _a[0];
        return match && +match + 1;
    };
    Uploader.prototype.setupXHR = function (xhr) {
        var _this = this;
        //reset response
        this.responseStatus = null;
        this.response = null;
        this.statusType = null;
        this._xhr_ = xhr;
        xhr.responseType = 'json';
        xhr.withCredentials = this.options.withCredentials;
        Object.keys(this.headers).forEach(function (key) { return xhr.setRequestHeader(key, _this.headers[key]); });
        // tslint:disable-next-line: no-unused-expression
        this._token && xhr.setRequestHeader('Authorization', "Bearer " + this._token);
    };
    Uploader.prototype.request = function (method, payload) {
        var _this = this;
        if (payload === void 0) { payload = null; }
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open(method.toUpperCase(), _this.URI, true);
            _this.setupXHR(xhr);
            xhr.onload = function () {
                _this.processResponse(xhr);
                resolve();
            };
            xhr.onerror = function () { return reject(); };
            var body = payload ? JSON.stringify(payload) : null;
            xhr.send(body);
        });
    };
    return Uploader;
}());
function getKeyFromResponse(xhr, key) {
    var fromHeader = xhr.getResponseHeader(key);
    if (fromHeader) {
        return fromHeader;
    }
    var response = parseJson(xhr) || {};
    var resKey = Object.keys(response).find(function (k) { return k.toLowerCase() === key.toLowerCase(); });
    return response[resKey];
}
function parseJson(xhr) {
    return typeof xhr.response === 'object' ? xhr.response : JSON.parse(xhr.responseText || null);
}
function unfunc(value, file) {
    return value instanceof Function ? value(file) : value;
}

var UploadxService = /** @class */ (function () {
    function UploadxService() {
        var _this = this;
        this.eventsStream = new Subject();
        this.queue = [];
        this.concurrency = 2;
        this.autoUpload = true;
        this.stateChange = function (evt) {
            setTimeout(function () {
                _this.eventsStream.next(evt);
            });
        };
        this.events.subscribe(function (evt) {
            if (evt.status !== 'uploading' && evt.status !== 'added') {
                _this.processQueue();
            }
        });
    }
    Object.defineProperty(UploadxService.prototype, "events", {
        get: function () {
            return this.eventsStream.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UploadxService.prototype, "uploaderOptions", {
        get: function () {
            return {
                method: this.options.method || 'POST',
                // tslint:disable-next-line: deprecation
                endpoint: this.options.endpoint || this.options.url || '/upload',
                headers: this.options.headers,
                metadata: this.options.metadata,
                token: this.options.token,
                chunkSize: this.options.chunkSize,
                withCredentials: this.options.withCredentials,
                maxRetryAttempts: this.options.maxRetryAttempts,
                stateChange: this.stateChange
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes service
     * @param options global options
     * @returns Observable that emits a new value on progress or status changes
     */
    UploadxService.prototype.init = function (options) {
        this.options = options;
        this.concurrency = options.concurrency || this.concurrency;
        this.autoUpload = !(options.autoUpload === false);
        return this.events;
    };
    /**
     * Initializes service
     * @param options global options
     * @returns Observable that emits the current queue
     */
    UploadxService.prototype.connect = function (options) {
        var _this = this;
        return this.init(options || this.options).pipe(startWith(0), map(function () { return _this.queue; }));
    };
    /**
     * Terminate all uploads and clears the queue
     */
    UploadxService.prototype.disconnect = function () {
        this.queue.forEach(function (f) { return (f.status = 'paused'); });
        this.queue = [];
    };
    /**
     * Create Uploader and add to the queue
     */
    UploadxService.prototype.handleFileList = function (fileList) {
        for (var i = 0; i < fileList.length; i++) {
            var uploader = new Uploader(fileList.item(i), this.uploaderOptions);
            this.queue.push(uploader);
            uploader.status = 'added';
        }
        this.autoUploadFiles();
    };
    /**
     * Create Uploader for the file and add to the queue
     */
    UploadxService.prototype.handleFile = function (file) {
        var uploader = new Uploader(file, this.uploaderOptions);
        this.queue.push(uploader);
        uploader.status = 'added';
        this.autoUploadFiles();
    };
    /**
     * Auto upload the files if the flag is true
     * @internal
     */
    UploadxService.prototype.autoUploadFiles = function () {
        if (this.autoUpload) {
            this.queue.filter(function (f) { return f.status === 'added'; }).forEach(function (f) { return (f.status = 'queue'); });
        }
    };
    /**
     * Control uploads status
     * @example
     * this.uploadService.control({ action: 'pauseAll' });
     *
     */
    UploadxService.prototype.control = function (event) {
        switch (event.action) {
            case 'cancelAll':
                this.queue.forEach(function (f) { return (f.status = 'cancelled'); });
                break;
            case 'pauseAll':
                this.queue.forEach(function (f) { return (f.status = 'paused'); });
                break;
            case 'refreshToken':
                this.queue.forEach(function (f) { return f.refreshToken(event.token); });
                break;
            case 'uploadAll':
                this.queue.filter(function (f) { return f.status !== 'uploading'; }).forEach(function (f) { return (f.status = 'queue'); });
                break;
            case 'upload':
                var uploadId_1 = event.uploadId || event.itemOptions.uploadId;
                var upload = this.queue.find(function (f) { return f.uploadId === uploadId_1; });
                upload.configure(event.itemOptions);
                upload.status = 'queue';
                break;
            case 'cancel':
                this.queue.find(function (f) { return f.uploadId === event.uploadId; }).status = 'cancelled';
                break;
            case 'pause':
                this.queue.find(function (f) { return f.uploadId === event.uploadId; }).status = 'paused';
                break;
            default:
                break;
        }
    };
    /**
     * Queue management
     * @internal
     */
    UploadxService.prototype.processQueue = function () {
        // Remove Cancelled Items from local queue
        this.queue = this.queue.filter(function (f) { return f.status !== 'cancelled'; });
        var running = this.runningProcess();
        this.queue
            .filter(function (uploader) { return uploader.status === 'queue'; })
            .slice(0, Math.max(this.concurrency - running, 0))
            .forEach(function (uploader) {
            uploader.upload();
        });
    };
    /**
     * @returns  number of active uploads
     */
    UploadxService.prototype.runningProcess = function () {
        return this.queue.filter(function (uploader) { return uploader.status === 'uploading' || uploader.status === 'retry'; }).length;
    };
    UploadxService.ngInjectableDef = defineInjectable({ factory: function UploadxService_Factory() { return new UploadxService(); }, token: UploadxService, providedIn: "root" });
    UploadxService = __decorate([
        Injectable({ providedIn: 'root' }),
        __metadata("design:paramtypes", [])
    ], UploadxService);
    return UploadxService;
}());

var UploadxDirective = /** @class */ (function () {
    function UploadxDirective(elementRef, renderer, uploadService) {
        var _this = this;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.uploadService = uploadService;
        this.uploadxState = new EventEmitter();
        this.fileListener = function () {
            if (_this.elementRef.nativeElement.files) {
                _this.uploadService.handleFileList(_this.elementRef.nativeElement.files);
            }
        };
    }
    Object.defineProperty(UploadxDirective.prototype, "uploadxAction", {
        set: function (ctrlEvent) {
            if (ctrlEvent && this.uploadService) {
                this.uploadService.control(ctrlEvent);
            }
        },
        enumerable: true,
        configurable: true
    });
    UploadxDirective.prototype.ngOnInit = function () {
        if (this.uploadx) {
            if (this.uploadx.allowedTypes) {
                this.renderer.setAttribute(this.elementRef.nativeElement, 'accept', this.uploadx.allowedTypes);
            }
            this.uploadService.init(this.uploadx);
        }
        this.uploadxState.emit(this.uploadService.events);
        this.listenerFn = this.renderer.listen(this.elementRef.nativeElement, 'change', this.fileListener);
    };
    UploadxDirective.prototype.ngOnDestroy = function () {
        if (this.listenerFn) {
            this.listenerFn();
        }
    };
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], UploadxDirective.prototype, "uploadxState", void 0);
    __decorate([
        Input(),
        __metadata("design:type", UploadxOptions)
    ], UploadxDirective.prototype, "uploadx", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], UploadxDirective.prototype, "uploadxAction", null);
    UploadxDirective = __decorate([
        Directive({
            selector: '[uploadx]'
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            UploadxService])
    ], UploadxDirective);
    return UploadxDirective;
}());

var UploadxModule = /** @class */ (function () {
    function UploadxModule() {
    }
    UploadxModule = __decorate([
        NgModule({
            imports: [CommonModule],
            declarations: [UploadxDirective],
            exports: [UploadxDirective]
        })
    ], UploadxModule);
    return UploadxModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { Uploader, UploadxModule, UploadxOptions, UploadxService, UploadxDirective as ɵa };
//# sourceMappingURL=ngx-uploadx.js.map

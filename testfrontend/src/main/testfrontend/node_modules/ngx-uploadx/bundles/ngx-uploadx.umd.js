(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ngx-uploadx', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global['ngx-uploadx'] = {}, global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, common, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    /**
     * Global Options
     */
    var UploadxOptions = /** @class */ (function () {
        function UploadxOptions() {
        }
        return UploadxOptions;
    }());

    function resolveUrl(url, baseURI) {
        if (url.indexOf('//') * url.indexOf('https://') * url.indexOf('http://') === 0) {
            return url;
        }
        try {
            var res = new URL(url, baseURI).href;
            return res;
        }
        catch (_a) {
            if (url.indexOf('/') === 0) {
                var matches = baseURI.match(/^(?:https?:)?(?:\/\/)?([^\/\?]+)/g);
                var origin_1 = matches && matches[0];
                return origin_1 + url;
            }
            else {
                var matches = baseURI.match(/^(?:https?:)?(?:\/\/)?([^\/\?]+)?(.*\/)/g);
                var path = matches && matches[0];
                return path + url;
            }
        }
    }

    /**
     *  Exponential Backoff Retries
     */
    var BackoffRetry = /** @class */ (function () {
        /**
         * @param min  Initial retry delay
         * @param max  Max retry delay
         * @param k    Increase factor
         */
        function BackoffRetry(min, max, k) {
            if (min === void 0) { min = 200; }
            if (max === void 0) { max = min * 300; }
            if (k === void 0) { k = 2; }
            this.min = min;
            this.max = max;
            this.k = k;
            this.code = -1;
            this.retryAttempts = 1;
            this.delay = this.min;
        }
        /**
         * Delay Retry
         * @param code
         * @returns retryAttempts
         */
        BackoffRetry.prototype.wait = function (code) {
            var _this = this;
            return new Promise(function (resolve) {
                if (code === _this.code) {
                    _this.retryAttempts++;
                    _this.delay = Math.min(_this.delay * _this.k, _this.max);
                }
                else {
                    _this.delay = _this.min;
                    _this.retryAttempts = 1;
                }
                _this.code = code;
                setTimeout(function () { return resolve(_this.retryAttempts); }, _this.delay + Math.floor(Math.random() * _this.min));
            });
        };
        /**
         * Reset Retry
         */
        BackoffRetry.prototype.reset = function () {
            this.delay = this.min;
            this.retryAttempts = 1;
            this.code = -1;
        };
        return BackoffRetry;
    }());

    /**
     * Implements XHR/CORS Resumable Upload
     * @see
     * https://developers.google.com/drive/v3/web/resumable-upload
     */
    var noop = function () { };
    var Uploader = /** @class */ (function () {
        /**
         * Creates an instance of Uploader.
         */
        function Uploader(file, options) {
            this.file = file;
            this.options = options;
            this.retry = new BackoffRetry();
            this.chunkSize = 1048576;
            this.maxRetryAttempts = 3;
            this.uploadId = Math.random()
                .toString(36)
                .substring(2, 15);
            this.name = file.name;
            this.size = file.size;
            this.mimeType = file.type || 'application/octet-stream';
            this.stateChange = options.stateChange || noop;
            this.configure(options);
        }
        Object.defineProperty(Uploader.prototype, "status", {
            get: function () {
                return this._status;
            },
            set: function (s) {
                // Return if State is cancelled or complete (but allow cancel of an complete upload to remove from list and from server)
                if (this._status === 'cancelled' || (this._status === 'complete' && s !== 'cancelled')) {
                    return;
                }
                if (s !== this._status) {
                    if (this._xhr_ && (s === 'cancelled' || s === 'paused')) {
                        this._xhr_.abort();
                    }
                    if (s === 'cancelled' && this.URI) {
                        this.request('delete');
                    }
                    this._status = s;
                    this.notifyState();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * configure or reconfigure uploader
         */
        Uploader.prototype.configure = function (item) {
            if (item === void 0) { item = {}; }
            var metadata = item.metadata, headers = item.headers, token = item.token, endpoint = item.endpoint;
            this.metadata = __assign({ name: this.name, mimeType: this.mimeType, size: this.file.size, lastModified: this.file.lastModified }, unfunc(metadata || this.metadata, this.file));
            this.endpoint = endpoint || this.options.endpoint;
            this.chunkSize = this.options.chunkSize || this.chunkSize;
            this.maxRetryAttempts = this.options.maxRetryAttempts || this.maxRetryAttempts;
            this.refreshToken(token);
            this.headers = __assign({}, this.headers, unfunc(headers, this.file));
        };
        /**
         * Emit current state
         */
        Uploader.prototype.notifyState = function () {
            var state = {
                file: this.file,
                name: this.name,
                progress: this.progress,
                percentage: this.progress,
                remaining: this.remaining,
                response: this.response,
                responseStatus: this.responseStatus,
                size: this.size,
                speed: this.speed,
                status: this._status,
                uploadId: this.uploadId,
                URI: this.URI
            };
            this.stateChange(state);
        };
        Uploader.prototype.processResponse = function (xhr) {
            this.responseStatus = xhr.status;
            this.response = parseJson(xhr);
            this.statusType = xhr.status - (xhr.status % 100);
        };
        Uploader.prototype.refreshToken = function (token) {
            this.token = token || this.token;
            this._token = unfunc(this.token);
        };
        Uploader.prototype.maxAttemptsReached = function () {
            if (this.retry.retryAttempts === this.maxRetryAttempts && this.statusType === 400) {
                this.retry.reset();
                console.error("Error: Maximum number of retry attempts reached:\n          file: " + this.name + ",\n          statusCode: " + this.responseStatus);
                return true;
            }
        };
        Uploader.prototype.create = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!_this.URI || _this.responseStatus === 404) {
                    // get file URI
                    var xhr_1 = new XMLHttpRequest();
                    xhr_1.open(_this.options.method.toUpperCase(), _this.endpoint, true);
                    _this.setupXHR(xhr_1);
                    xhr_1.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
                    xhr_1.setRequestHeader('X-Upload-Content-Length', _this.size.toString());
                    xhr_1.setRequestHeader('X-Upload-Content-Type', _this.mimeType);
                    xhr_1.onload = function () {
                        _this.processResponse(xhr_1);
                        var location = _this.statusType === 200 && getKeyFromResponse(xhr_1, 'location');
                        if (!location) {
                            // limit attempts
                            _this.statusType = 400;
                            reject();
                        }
                        else {
                            _this.URI = resolveUrl(location, _this.endpoint);
                            _this.retry.reset();
                            resolve();
                        }
                    };
                    xhr_1.onerror = function () { return reject(); };
                    xhr_1.send(JSON.stringify(_this.metadata));
                }
                else {
                    resolve();
                }
            });
        };
        /**
         * Initiate upload
         */
        Uploader.prototype.upload = function (item) {
            return __awaiter(this, void 0, void 0, function () {
                var e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (item)
                                this.configure(item);
                            if (this._status === 'cancelled' || this._status === 'complete' || this._status === 'paused') {
                                return [2 /*return*/];
                            }
                            this.status = 'uploading';
                            this.refreshToken();
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 7]);
                            return [4 /*yield*/, this.create()];
                        case 2:
                            _a.sent();
                            this.startTime = new Date().getTime();
                            this.sendChunk(this.progress ? undefined : 0);
                            return [3 /*break*/, 7];
                        case 3:
                            e_1 = _a.sent();
                            if (!this.maxAttemptsReached()) return [3 /*break*/, 4];
                            this.status = 'error';
                            return [3 /*break*/, 6];
                        case 4:
                            this.status = 'retry';
                            return [4 /*yield*/, this.retry.wait(this.responseStatus)];
                        case 5:
                            _a.sent();
                            this.status = 'queue';
                            _a.label = 6;
                        case 6: return [3 /*break*/, 7];
                        case 7: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Chunk upload +/ get offset
         */
        Uploader.prototype.sendChunk = function (offset) {
            if (this.status === 'uploading') {
                var body = null;
                var xhr = new XMLHttpRequest();
                xhr.open('PUT', this.URI, true);
                this.setupXHR(xhr);
                this.setupEvents(xhr);
                if (offset >= 0 && offset < this.size) {
                    var end = this.chunkSize ? Math.min(offset + this.chunkSize, this.size) : this.size;
                    body = this.file.slice(offset, end);
                    xhr.upload.onprogress = this.setupProgressEvent(offset, end);
                    xhr.setRequestHeader('Content-Range', "bytes " + offset + "-" + (end - 1) + "/" + this.size);
                    xhr.setRequestHeader('Content-Type', 'application/octet-stream');
                }
                else {
                    xhr.setRequestHeader('Content-Range', "bytes */" + this.size);
                }
                xhr.send(body);
            }
        };
        Uploader.prototype.setupEvents = function (xhr) {
            var _this = this;
            var onError = function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.maxAttemptsReached()) {
                                this.status = 'error';
                                return [2 /*return*/];
                            }
                            this.status = 'retry';
                            return [4 /*yield*/, this.retry.wait(xhr.status)];
                        case 1:
                            _a.sent();
                            if (xhr.status === 404) {
                                this.status = 'queue';
                                return [2 /*return*/];
                            }
                            if (xhr.status === 413) {
                                this.chunkSize /= 2;
                            }
                            this.refreshToken();
                            this.status = 'uploading';
                            // request offset
                            this.sendChunk();
                            return [2 /*return*/];
                    }
                });
            }); };
            var onSuccess = function () {
                _this.processResponse(xhr);
                var offset = _this.statusType === 300 && _this.getNextChunkOffset(xhr);
                if (typeof offset === 'number') {
                    //  next chunk
                    _this.retry.reset();
                    _this.sendChunk(offset);
                }
                else if (_this.statusType === 200) {
                    _this.progress = 100;
                    _this.status = 'complete';
                }
                else {
                    onError();
                }
            };
            xhr.onerror = onError;
            xhr.onload = onSuccess;
        };
        Uploader.prototype.setupProgressEvent = function (offset, end) {
            var _this = this;
            return function (pEvent) {
                var uploaded = pEvent.lengthComputable
                    ? offset + (end - offset) * (pEvent.loaded / pEvent.total)
                    : offset;
                _this.progress = +((uploaded / _this.size) * 100).toFixed(2);
                var now = new Date().getTime();
                _this.speed = Math.round((uploaded / (now - _this.startTime)) * 1000);
                _this.remaining = Math.ceil((_this.size - uploaded) / _this.speed);
                _this.notifyState();
            };
        };
        Uploader.prototype.getNextChunkOffset = function (xhr) {
            var str = getKeyFromResponse(xhr, 'Range');
            var _a = __read(str && str.match(/(-1|\d+)$/g), 1), match = _a[0];
            return match && +match + 1;
        };
        Uploader.prototype.setupXHR = function (xhr) {
            var _this = this;
            //reset response
            this.responseStatus = null;
            this.response = null;
            this.statusType = null;
            this._xhr_ = xhr;
            xhr.responseType = 'json';
            xhr.withCredentials = this.options.withCredentials;
            Object.keys(this.headers).forEach(function (key) { return xhr.setRequestHeader(key, _this.headers[key]); });
            // tslint:disable-next-line: no-unused-expression
            this._token && xhr.setRequestHeader('Authorization', "Bearer " + this._token);
        };
        Uploader.prototype.request = function (method, payload) {
            var _this = this;
            if (payload === void 0) { payload = null; }
            return new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open(method.toUpperCase(), _this.URI, true);
                _this.setupXHR(xhr);
                xhr.onload = function () {
                    _this.processResponse(xhr);
                    resolve();
                };
                xhr.onerror = function () { return reject(); };
                var body = payload ? JSON.stringify(payload) : null;
                xhr.send(body);
            });
        };
        return Uploader;
    }());
    function getKeyFromResponse(xhr, key) {
        var fromHeader = xhr.getResponseHeader(key);
        if (fromHeader) {
            return fromHeader;
        }
        var response = parseJson(xhr) || {};
        var resKey = Object.keys(response).find(function (k) { return k.toLowerCase() === key.toLowerCase(); });
        return response[resKey];
    }
    function parseJson(xhr) {
        return typeof xhr.response === 'object' ? xhr.response : JSON.parse(xhr.responseText || null);
    }
    function unfunc(value, file) {
        return value instanceof Function ? value(file) : value;
    }

    var UploadxService = /** @class */ (function () {
        function UploadxService() {
            var _this = this;
            this.eventsStream = new rxjs.Subject();
            this.queue = [];
            this.concurrency = 2;
            this.autoUpload = true;
            this.stateChange = function (evt) {
                setTimeout(function () {
                    _this.eventsStream.next(evt);
                });
            };
            this.events.subscribe(function (evt) {
                if (evt.status !== 'uploading' && evt.status !== 'added') {
                    _this.processQueue();
                }
            });
        }
        Object.defineProperty(UploadxService.prototype, "events", {
            get: function () {
                return this.eventsStream.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UploadxService.prototype, "uploaderOptions", {
            get: function () {
                return {
                    method: this.options.method || 'POST',
                    // tslint:disable-next-line: deprecation
                    endpoint: this.options.endpoint || this.options.url || '/upload',
                    headers: this.options.headers,
                    metadata: this.options.metadata,
                    token: this.options.token,
                    chunkSize: this.options.chunkSize,
                    withCredentials: this.options.withCredentials,
                    maxRetryAttempts: this.options.maxRetryAttempts,
                    stateChange: this.stateChange
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes service
         * @param options global options
         * @returns Observable that emits a new value on progress or status changes
         */
        UploadxService.prototype.init = function (options) {
            this.options = options;
            this.concurrency = options.concurrency || this.concurrency;
            this.autoUpload = !(options.autoUpload === false);
            return this.events;
        };
        /**
         * Initializes service
         * @param options global options
         * @returns Observable that emits the current queue
         */
        UploadxService.prototype.connect = function (options) {
            var _this = this;
            return this.init(options || this.options).pipe(operators.startWith(0), operators.map(function () { return _this.queue; }));
        };
        /**
         * Terminate all uploads and clears the queue
         */
        UploadxService.prototype.disconnect = function () {
            this.queue.forEach(function (f) { return (f.status = 'paused'); });
            this.queue = [];
        };
        /**
         * Create Uploader and add to the queue
         */
        UploadxService.prototype.handleFileList = function (fileList) {
            for (var i = 0; i < fileList.length; i++) {
                var uploader = new Uploader(fileList.item(i), this.uploaderOptions);
                this.queue.push(uploader);
                uploader.status = 'added';
            }
            this.autoUploadFiles();
        };
        /**
         * Create Uploader for the file and add to the queue
         */
        UploadxService.prototype.handleFile = function (file) {
            var uploader = new Uploader(file, this.uploaderOptions);
            this.queue.push(uploader);
            uploader.status = 'added';
            this.autoUploadFiles();
        };
        /**
         * Auto upload the files if the flag is true
         * @internal
         */
        UploadxService.prototype.autoUploadFiles = function () {
            if (this.autoUpload) {
                this.queue.filter(function (f) { return f.status === 'added'; }).forEach(function (f) { return (f.status = 'queue'); });
            }
        };
        /**
         * Control uploads status
         * @example
         * this.uploadService.control({ action: 'pauseAll' });
         *
         */
        UploadxService.prototype.control = function (event) {
            switch (event.action) {
                case 'cancelAll':
                    this.queue.forEach(function (f) { return (f.status = 'cancelled'); });
                    break;
                case 'pauseAll':
                    this.queue.forEach(function (f) { return (f.status = 'paused'); });
                    break;
                case 'refreshToken':
                    this.queue.forEach(function (f) { return f.refreshToken(event.token); });
                    break;
                case 'uploadAll':
                    this.queue.filter(function (f) { return f.status !== 'uploading'; }).forEach(function (f) { return (f.status = 'queue'); });
                    break;
                case 'upload':
                    var uploadId_1 = event.uploadId || event.itemOptions.uploadId;
                    var upload = this.queue.find(function (f) { return f.uploadId === uploadId_1; });
                    upload.configure(event.itemOptions);
                    upload.status = 'queue';
                    break;
                case 'cancel':
                    this.queue.find(function (f) { return f.uploadId === event.uploadId; }).status = 'cancelled';
                    break;
                case 'pause':
                    this.queue.find(function (f) { return f.uploadId === event.uploadId; }).status = 'paused';
                    break;
                default:
                    break;
            }
        };
        /**
         * Queue management
         * @internal
         */
        UploadxService.prototype.processQueue = function () {
            // Remove Cancelled Items from local queue
            this.queue = this.queue.filter(function (f) { return f.status !== 'cancelled'; });
            var running = this.runningProcess();
            this.queue
                .filter(function (uploader) { return uploader.status === 'queue'; })
                .slice(0, Math.max(this.concurrency - running, 0))
                .forEach(function (uploader) {
                uploader.upload();
            });
        };
        /**
         * @returns  number of active uploads
         */
        UploadxService.prototype.runningProcess = function () {
            return this.queue.filter(function (uploader) { return uploader.status === 'uploading' || uploader.status === 'retry'; }).length;
        };
        UploadxService.ngInjectableDef = core.defineInjectable({ factory: function UploadxService_Factory() { return new UploadxService(); }, token: UploadxService, providedIn: "root" });
        UploadxService = __decorate([
            core.Injectable({ providedIn: 'root' }),
            __metadata("design:paramtypes", [])
        ], UploadxService);
        return UploadxService;
    }());

    var UploadxDirective = /** @class */ (function () {
        function UploadxDirective(elementRef, renderer, uploadService) {
            var _this = this;
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.uploadService = uploadService;
            this.uploadxState = new core.EventEmitter();
            this.fileListener = function () {
                if (_this.elementRef.nativeElement.files) {
                    _this.uploadService.handleFileList(_this.elementRef.nativeElement.files);
                }
            };
        }
        Object.defineProperty(UploadxDirective.prototype, "uploadxAction", {
            set: function (ctrlEvent) {
                if (ctrlEvent && this.uploadService) {
                    this.uploadService.control(ctrlEvent);
                }
            },
            enumerable: true,
            configurable: true
        });
        UploadxDirective.prototype.ngOnInit = function () {
            if (this.uploadx) {
                if (this.uploadx.allowedTypes) {
                    this.renderer.setAttribute(this.elementRef.nativeElement, 'accept', this.uploadx.allowedTypes);
                }
                this.uploadService.init(this.uploadx);
            }
            this.uploadxState.emit(this.uploadService.events);
            this.listenerFn = this.renderer.listen(this.elementRef.nativeElement, 'change', this.fileListener);
        };
        UploadxDirective.prototype.ngOnDestroy = function () {
            if (this.listenerFn) {
                this.listenerFn();
            }
        };
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], UploadxDirective.prototype, "uploadxState", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", UploadxOptions)
        ], UploadxDirective.prototype, "uploadx", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], UploadxDirective.prototype, "uploadxAction", null);
        UploadxDirective = __decorate([
            core.Directive({
                selector: '[uploadx]'
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                UploadxService])
        ], UploadxDirective);
        return UploadxDirective;
    }());

    var UploadxModule = /** @class */ (function () {
        function UploadxModule() {
        }
        UploadxModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [UploadxDirective],
                exports: [UploadxDirective]
            })
        ], UploadxModule);
        return UploadxModule;
    }());

    exports.Uploader = Uploader;
    exports.UploadxModule = UploadxModule;
    exports.UploadxOptions = UploadxOptions;
    exports.UploadxService = UploadxService;
    exports.ɵa = UploadxDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngx-uploadx.umd.js.map
